<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>K1986BE92 SPL programming.ctd</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body>
    <div class='page'><h1 class='title level-1'>Программирование с использованием SPL для K1986BE92</h1><br/>1. <a href="Программирование_с_использованием_SPL_для_K1986BE92--Работа_с_портами.html">Работа с портами.</a><br />2. <a href="Программирование_с_использованием_SPL_для_K1986BE92--Работа_с_UART.html">Работа с UART</a></div><div class='page'><h1 class='title level-2'>Работа с портами</h1><br/><h2>	Для удобства настройки портов ввода-вывода используем специальную структуру типа </h2><strong><h2>PORT_InitTypeDef</h2></strong><h2>. Вот пример ее описания: </h2><em><strong><h2>PORT_InitTypeDef GPIOInitStruct;</h2></strong></em><h2> <br />Тип </h2><strong><h2>PORT_InitTypeDef</h2></strong><h2> описан в заголовке MDR32F9Qx_port.h.<br />	Перед использованием структуры для конфигурации очередного набора линий ввода-вывода инициализируем ее следующим образом:  </h2><em><strong><h2>PORT_StructInit(&amp;GPIOInitStruct);</h2></strong></em><h2><br />Чтобы упростить работу с пинами, в модуле MDR32F9Qx_port.h предусмотрен ряд констант, описывающих соответствующие линии:</h2><br /><div class="codebox"><div class="codebox"><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_0&nbsp;0x0001</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_1&nbsp;0x0002</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_2&nbsp;0x0004</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_3&nbsp;0x0008</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_4&nbsp;0x0010</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_5&nbsp;0x0020</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_6&nbsp;0x0040</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_7&nbsp;0x0080</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_8&nbsp;0x0100</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_9&nbsp;0x0200</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_10&nbsp;0x0400</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_11&nbsp;0x0800</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_12&nbsp;0x1000</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_13&nbsp;0x2000</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_14&nbsp;0x4000</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_15&nbsp;0x8000</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;PORT_Pin_All&nbsp;0xFFFF</span></div></div><br /><h2>	Применяя к этим константам операцию поразрядного ИЛИ (символ | ), можно легко и понятно указывать требуемый для конфигурации набор линий. Например, если требуется сконфигурировать линии 2, 3 и 5,<br />следует написать: <br /></h2><em><strong><h2>GPIOInitStruct.PORT_Pin = PORT_Pin_2 | PORT_Pin_3 | PORT_Pin_5;</h2></strong></em><h2> Если требуется сконфигурировать только линию 4, то это выглядит так: </h2><em><strong><h2>GPIOInitStruct.PORT_Pin = PORT_Pin_4;</h2></strong></em><h2> <br />Константа </h2><strong><h2>PORT_Pin_All</h2></strong><h2> описывает сразу все 16 линий.<br />В поле </h2><strong><h2>PORT_MODE</h2></strong><h2> типа </h2><strong><h2>PORT_MODE_TypeDef</h2></strong><h2> указывают режим работы выбранных пинов. Здесь возможны два варианта значений:<br />- PORT_MODE_ANALOG – линия является аналоговой;<br />- PORT_MODE_DIGITAL – линия является цифровой.<br />Режим аналоговой линии выбирается, если требуется работать с АЦП, ЦАП, аналоговым компаратором или внешним низкочастотным кварцевым резонатором. В остальных случаях используется режим цифровой<br />линии.<br />Для указания линии порта в каком состоянии она будет (вход или выход) используется поле </h2><strong><h2>PORT_OE</h2></strong><h2>.<br />Пример для выхода: </h2><em><strong><h2>GPIOInitStruct.PORT_OE = PORT_OE_OUT;</h2></strong></em><h2> соответственно для входа </h2><em><strong><h2>GPIOInitStruct.PORT_OE = PORT_OE_IN;</h2></strong></em><h2><br />	В поле </h2><strong><h2>PORT_SPEED</h2></strong><h2> указывают примерную скорость работы линии, т.е. какой частоты сигнал может через нее проходить. Возможны следующие значения:<br />- </h2><strong><h2>PORT_OUTPUT_OFF</h2></strong><h2> – выход выключен;<br />- </h2><strong><h2>PORT_SPEED_SLOW</h2></strong><h2> – низкая скорость (фронт порядка 100 нс, частота до 5 МГц);<br />- </h2><strong><h2>PORT_SPEED_FAST</h2></strong><h2> – высокая скорость (фронт порядка 20 нс, частота до 25 МГц);<br />- </h2><strong><h2>PORT_SPEED_MAXFAST</h2></strong><h2> – предельно высокая скорость (фронт порядка 10 нс, частота до 50 МГц).<br />Этот параметр влияет на форму фронтов формируемых импульсов. Если выбрать высокую скорость, то фронты будут крутыми, а если низкую – то пологими. Крутые фронты необходимы на высоких частотах, но они создают широкий спектр помех, что может неблагоприятно сказаться на работе<br />схемы. Пологие же фронты создают гораздо меньше помех, но на больших частотах неприменимы. Пример: </h2><em><strong><h2>GPIOInitStruct.PORT_SPEED = PORT_SPEED_SLOW;</h2></strong></em><h2><br />	Поле </h2><strong><h2>PORT_PD</h2></strong><h2> задает тип цифрового выхода:<br />- </h2><strong><h2>PORT_PD_DRIVER</h2></strong><h2> – управляемый драйвер;<br />- </h2><strong><h2>PORT_PD_OPEN</h2></strong><h2> – открытый сток. Пример: </h2><em><strong><h2>GPIOInitStruct.PORT_PD = PORT_PD_DRIVER;</h2></strong></em><h2><br />	В полях </h2><strong><h2>PORT_PULL_UP</h2></strong><h2> и </h2><strong><h2>PORT_PULL_DOWN</h2></strong><h2> задают конфигурацию резисторов подтяжки линии ввода-вывода к цепям питания микроконтроллера. </h2><strong><h2>PORT_PULL_UP</h2></strong><h2> управляет резистором для подтяжки к<br />плюсу питания. Возможны следующие значения:<br />- </h2><strong><h2>PORT_PULL_UP_OFF</h2></strong><h2> – резистор подтяжки не используется;<br />- </h2><strong><h2>PORT_PULL_UP_ON</h2></strong><h2> – резистор подтяжки используется.<br />- </h2><strong><h2>PORT_PULL_DOWN</h2></strong><h2> управляет резистором для подтяжки к земле. Возможны следующие значения:<br />- </h2><strong><h2>PORT_PULL_DOWN_OFF</h2></strong><h2> – резистор подтяжки не используется;<br />- </h2><strong><h2>PORT_PULL_DOWN_ON</h2></strong><h2> – резистор подтяжки используется.<br />	Когда поля структуры заполнены, вводим в действие требуемую конфигурацию </h2><em><strong><h2>PORT_Init (MDR_PORTC, &amp;GPIOInitStruct);</h2></strong></em><h2> Первым параметром указывают название порта, для которого производится<br />конфигурация. Предопределенные названия находятся в заголовке MDR32F9Qx_port.h:<br />MDR_PORTA, MDR_PORTB, MDR_PORTC, MDR_PORTD, MDR_PORTE и MDR_PORTF. Если требуется сконфигурировать пины из нескольких портов, то и функция </h2><strong><h2>PORT_Init </h2></strong><h2>должна вызываться несколько раз:<br />отдельно для каждого порта.Также для нормальной работы портов необходимо разрешить их тактирование. Это делается путем вызова специальной функции </h2><strong><h2>RST_CLK_PCLKcmd</h2></strong><h2> из библиотечного модуля<br />MDR32F9Qx_rst_clk.c: <br /></h2><em><strong><h2>RST_CLK_PCLKcmd (RST_CLK_PCLK_PORTB | RST_CLK_PCLK_PORTB |RST_CLK_PCLK_PORTB | RST_CLK_PCLK_PORTB | RST_CLK_PCLK_PORTB | RST_CLK_PCLK_PORTB,ENABLE);</h2></strong></em><br /><br /><h2>Пример программы мигание светодиодом на порту PB1:</h2><br /><br /><div class="codebox"><div class="codebox"><span style="color:#0088ff;font-weight:400">#include&nbsp;&lt;MDR32F9Qx_port.h&gt;</span><br /><span style="color:#0088ff;font-weight:400">#include&nbsp;&lt;MDR32F9Qx_rst_clk.h&gt;</span><br /><br /><span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Определения<br /><span style="color:#0088ff;font-weight:400">#define&nbsp;LED_PERIOD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000000</span><br /><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;LED_PORT_CLK&nbsp;&nbsp;&nbsp;&nbsp;RST_CLK_PCLK_PORTB</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;LED_PORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MDR_PORTB</span><br /><span style="color:#0088ff;font-weight:400">#define&nbsp;LED_PORT_PIN&nbsp;&nbsp;&nbsp;&nbsp;PORT_Pin_1</span><br /><br /><span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Прототип&nbsp;функции&nbsp;задержки,&nbsp;реализованной&nbsp;ниже<br />void&nbsp;Delay<span style="color:#ff9d00;font-weight:700">(</span>int&nbsp;waitTicks<span style="color:#ff9d00;font-weight:700">);</span><br /><br /><span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Точка&nbsp;входа,&nbsp;отсюда&nbsp;начинается&nbsp;исполнение&nbsp;программы<br />int&nbsp;<span style="color:#ffdd00;font-weight:400">main()</span><br /><span style="color:#ff9d00;font-weight:700">{</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;Заводим&nbsp;структуру&nbsp;конфигурации&nbsp;вывода<span style="color:#ff9d00;font-weight:700">(</span>-ов<span style="color:#ff9d00;font-weight:700">)</span>&nbsp;порта&nbsp;GPIO<br />&nbsp;&nbsp;PORT_InitTypeDef&nbsp;GPIOInitStruct<span style="color:#ff9d00;font-weight:700">;</span><br /><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Включаем&nbsp;тактирование&nbsp;порта&nbsp;LED_PORT_CLK<br />&nbsp;&nbsp;RST_CLK_PCLKcmd&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>LED_PORT_CLK,&nbsp;ENABLE<span style="color:#ff9d00;font-weight:700">);</span><br />	<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Инициализируем&nbsp;структуру&nbsp;конфигурации&nbsp;вывода<span style="color:#ff9d00;font-weight:700">(</span>-ов<span style="color:#ff9d00;font-weight:700">)</span>&nbsp;порта&nbsp;значениями&nbsp;по&nbsp;умолчанию<br />&nbsp;&nbsp;PORT_StructInit<span style="color:#ff9d00;font-weight:700">(&amp;</span>GPIOInitStruct<span style="color:#ff9d00;font-weight:700">);</span><br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Изменяем&nbsp;значения&nbsp;по&nbsp;умолчанию&nbsp;на&nbsp;необходимые&nbsp;нам&nbsp;настройки<br />&nbsp;&nbsp;GPIOInitStruct.PORT_Pin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;LED_PORT_PIN<span style="color:#ff9d00;font-weight:700">;</span><br />&nbsp;&nbsp;GPIOInitStruct.PORT_OE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PORT_OE_OUT<span style="color:#ff9d00;font-weight:700">;</span><br />&nbsp;&nbsp;GPIOInitStruct.PORT_SPEED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PORT_SPEED_SLOW<span style="color:#ff9d00;font-weight:700">;</span><br />&nbsp;&nbsp;GPIOInitStruct.PORT_MODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;PORT_MODE_DIGITAL<span style="color:#ff9d00;font-weight:700">;</span><br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Применяем&nbsp;заполненную&nbsp;нами&nbsp;структуру&nbsp;для&nbsp;LED_PORT<br />&nbsp;&nbsp;PORT_Init<span style="color:#ff9d00;font-weight:700">(</span>LED_PORT,&nbsp;<span style="color:#ff9d00;font-weight:700">&amp;</span>GPIOInitStruct<span style="color:#ff9d00;font-weight:700">);</span><br /><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Запускаем&nbsp;бесконечный&nbsp;цикл&nbsp;обработки&nbsp;-&nbsp;Основной&nbsp;цикл	<br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">while</span>&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>1<span style="color:#ff9d00;font-weight:700">)</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;Считываем&nbsp;состояние&nbsp;вывода&nbsp;LED_PORT_PIN<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;Если&nbsp;на&nbsp;выводе&nbsp;логический&nbsp;<span style="color:#3ad900;font-weight:400">&quot;0&quot;</span>,&nbsp;то&nbsp;выставляем&nbsp;вывод&nbsp;в&nbsp;логическую&nbsp;<span style="color:#3ad900;font-weight:400">&quot;1&quot;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>PORT_ReadInputDataBit&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>LED_PORT,&nbsp;LED_PORT_PIN<span style="color:#ff9d00;font-weight:700">)</span>&nbsp;==&nbsp;0<span style="color:#ff9d00;font-weight:700">)</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">{</span>	<br />	PORT_SetBits<span style="color:#ff9d00;font-weight:700">(</span>LED_PORT,&nbsp;LED_PORT_PIN<span style="color:#ff9d00;font-weight:700">);</span>	<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;LED<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">}</span>	<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Задержка&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Delay<span style="color:#ff9d00;font-weight:700">(</span>LED_PERIOD<span style="color:#ff9d00;font-weight:700">);</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;Считываем&nbsp;состояние&nbsp;вывода&nbsp;LED_PORT_PIN<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;Если&nbsp;на&nbsp;выводе&nbsp;=&nbsp;<span style="color:#3ad900;font-weight:400">&quot;1&quot;</span>,&nbsp;то&nbsp;выставляем&nbsp;<span style="color:#3ad900;font-weight:400">&quot;0&quot;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>PORT_ReadInputDataBit&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>LED_PORT,&nbsp;LED_PORT_PIN<span style="color:#ff9d00;font-weight:700">)</span>&nbsp;==&nbsp;1<span style="color:#ff9d00;font-weight:700">)</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">{</span><br />	PORT_ResetBits<span style="color:#ff9d00;font-weight:700">(</span>LED_PORT,&nbsp;LED_PORT_PIN<span style="color:#ff9d00;font-weight:700">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">};</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Задержка&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Delay<span style="color:#ff9d00;font-weight:700">(</span>LED_PERIOD<span style="color:#ff9d00;font-weight:700">);</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /><span style="color:#ff9d00;font-weight:700">}</span><br /><br /><span style="color:#ff9d00;font-weight:700">//</span>&nbsp;&nbsp;Простейшая&nbsp;функция&nbsp;задержки<br />void&nbsp;Delay<span style="color:#ff9d00;font-weight:700">(</span>int&nbsp;waitTicks<span style="color:#ff9d00;font-weight:700">)</span><br /><span style="color:#ff9d00;font-weight:700">{</span><br />&nbsp;&nbsp;int&nbsp;i<span style="color:#ff9d00;font-weight:700">;</span><br />&nbsp;&nbsp;<span style="color:#ff9d00;font-weight:700">for</span>&nbsp;(<span style="color:#7f0044;font-weight:400">i</span>&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;waitTicks;&nbsp;i++)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;__NOP();<br />&nbsp;&nbsp;}	<br />}</div></div><br /><br /><h2>Другой пример работы со светодиодами. К выводам 1 и 2 порта В подключены светодиоды (Red и Green), которые должны переключаться раз в секунду. Это можно сделать с<br />помощью прерываний при переполнении системного таймера SysTick.</h2><br /><br /><div class="codebox"><div class="codebox"><span style="color:#7f0044;font-weight:700">#include&nbsp;&quot;MDR32Fx.h&quot;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&quot;core_cm3.h&quot;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&quot;MDR32F9Qx_config.h&quot;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&quot;system_MDR32F9Qx.h&quot;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&quot;MDR32F9Qx_rst_clk.h&quot;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&quot;MDR32F9Qx_port.h&quot;</span><br /><br /><span style="color:#7f0044;font-weight:400">static</span>&nbsp;PORT_InitTypeDef&nbsp;PortInit;<span style="color:#0088ff;font-weight:400">//объявление&nbsp;структуры&nbsp;PortInit</span><br /><span style="color:#7f0044;font-weight:400">volatile</span>&nbsp;<span style="color:#7f0044;font-weight:400">uint32_t</span>&nbsp;delay_dec&nbsp;=&nbsp;<span style="color:#ff0044;font-weight:400">0</span>;<span style="color:#0088ff;font-weight:400">//&nbsp;объявление&nbsp;переменной&nbsp;delay_dec</span><br /><br /><span style="color:#0088ff;font-weight:400">//Обработчик&nbsp;прерывания&nbsp;системного&nbsp;таймера</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;SysTick_Handler&nbsp;(<span style="color:#7f0044;font-weight:400">void</span>)<br />{<br /><span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(delay_dec&nbsp;!=<span style="color:#ff0044;font-weight:400">0</span>)&nbsp;delay_dec--;<span style="color:#0088ff;font-weight:400">//вычитать&nbsp;из&nbsp;delay_dec,&nbsp;пока&nbsp;не&nbsp;станет&nbsp;равен&nbsp;0</span><br />}<br /><br /><span style="color:#0088ff;font-weight:400">//функцияв&nbsp;ременной&nbsp;задержки</span><br /><span style="color:#7f0044;font-weight:400">void</span>&nbsp;delay_ms&nbsp;(<span style="color:#7f0044;font-weight:400">uint32_t</span>&nbsp;delay_ms)<br />{<br />delay_dec&nbsp;=&nbsp;delay_ms;<span style="color:#0088ff;font-weight:400">//присвоить&nbsp;delay_dec&nbsp;значение&nbsp;delay_ms</span><br /><span style="color:#ff9d00;font-weight:700">while</span>&nbsp;(delay_dec)&nbsp;{};&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;выполнять&nbsp;функцию&nbsp;пока&nbsp;delay_dec&nbsp;не&nbsp;станет&nbsp;равным&nbsp;0</span><br />}<br /><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;main(){<br />RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTB,&nbsp;ENABLE);&nbsp;);<span style="color:#0088ff;font-weight:400">//включить&nbsp;тактирование&nbsp;порта&nbsp;B</span><br /><span style="color:#0088ff;font-weight:400">//Инициализация&nbsp;порта&nbsp;B</span><br />PortInit.PORT_OE&nbsp;=&nbsp;PORT_OE_OUT;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;направление&nbsp;передачи&nbsp;данных&nbsp;=&nbsp;Выход</span><br />PortInit.PORT_FUNC&nbsp;=&nbsp;PORT_FUNC_PORT;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;режим&nbsp;работы&nbsp;вывода&nbsp;порта&nbsp;=&nbsp;Порт</span><br />PortInit.PORT_MODE&nbsp;=&nbsp;PORT_MODE_DIGITAL;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;режим&nbsp;работы&nbsp;вывода=&nbsp;цифровой</span><br />PortInit.PORT_SPEED&nbsp;=&nbsp;PORT_SPEED_SLOW;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;скорость&nbsp;фронта&nbsp;вывода&nbsp;=&nbsp;медленная</span><br />PortInit.PORT_Pin&nbsp;=&nbsp;(PORT_Pin_All);<span style="color:#0088ff;font-weight:400">//&nbsp;выбор&nbsp;для&nbsp;инициализации</span><br />PORT_Init(MDR_PORTB,&nbsp;&amp;PortInit);&nbsp;<span style="color:#0088ff;font-weight:400">//инициализация&nbsp;порта&nbsp;B&nbsp;заданными&nbsp;параметрами</span><br /><span style="color:#0088ff;font-weight:400">//Инициализация&nbsp;системного&nbsp;таймера</span><br />SysTick-&gt;LOAD&nbsp;|=&nbsp;(<span style="color:#ff0044;font-weight:400">8000000</span>/<span style="color:#ff0044;font-weight:400">1000</span>)-<span style="color:#ff0044;font-weight:400">1</span>;&nbsp;<span style="color:#0088ff;font-weight:400">//значение&nbsp;задержки&nbsp;прерывания&nbsp;при&nbsp;тактовой&nbsp;частоте&nbsp;8&nbsp;МГц&nbsp;=&nbsp;1мс</span><br />SysTick-&gt;CTRL&nbsp;|=&nbsp;SysTick_CTRL_CLKSOURCE_Pos;&nbsp;<span style="color:#0088ff;font-weight:400">//источник&nbsp;тактирования&nbsp;HCLK</span><br />SysTick-&gt;CTRL&nbsp;|=&nbsp;SysTick_CTRL_COUNTFLAG_Pos;<span style="color:#0088ff;font-weight:400">//&nbsp;при&nbsp;досчитывании&nbsp;до&nbsp;нуля&nbsp;таймер&nbsp;генерирует&nbsp;прерывание</span><br />SysTick-&gt;CTRL&nbsp;|=&nbsp;~SysTick_CTRL_ENABLE_Pos;<span style="color:#0088ff;font-weight:400">//включить&nbsp;работу&nbsp;таймера</span><br /><br /><span style="color:#ff9d00;font-weight:700">while</span>(<span style="color:#ff0044;font-weight:400">1</span>)<br />{<br />delay_ms(<span style="color:#ff0044;font-weight:400">1000</span>);&nbsp;<span style="color:#0088ff;font-weight:400">//задержка&nbsp;1&nbsp;с</span><br />PORT_SetBits(MDR_PORTB,&nbsp;PORT_Pin_All);&nbsp;<span style="color:#0088ff;font-weight:400">//включить&nbsp;светодиоды</span><br />delay_ms(<span style="color:#ff0044;font-weight:400">1000</span>);<span style="color:#0088ff;font-weight:400">//задержка&nbsp;1&nbsp;с</span><br />PORT_ResetBits(MDR_PORTB,&nbsp;PORT_Pin_All);&nbsp;<span style="color:#0088ff;font-weight:400">//выключить&nbsp;светодиоды</span><br />}<br />}</div></div><br /><br /><h1>	</h1><strong><h1>Работа с цифровых входом.</h1></strong><br /><br /><h2>	Функция </h2><strong><h2>PORT_ReadInputDataBit()</h2></strong><h2> читает состояние определенного входа. В следующем примере производится чтение состояния входа PD5.<br /></h2><div class="codebox"><div class="codebox">uint8_t&nbsp;flag<span style="color:#ff9d00;font-weight:700">;</span><br />...<br />flag&nbsp;=&nbsp;PORT_ReadInputDataBit&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTD,&nbsp;PORT_Pin_5<span style="color:#ff9d00;font-weight:700">);</span></div></div><br />	Функция <strong>PORT_ReadInputData</strong> читает состояние всех входов указанного порта, возвращая 16-битное целое число (по количеству линий в порте):<br /><div class="codebox"><div class="codebox">uint16_t&nbsp;in_data<span style="color:#ff9d00;font-weight:700">;</span><br />...<br />in_data&nbsp;=&nbsp;PORT_ReadInputData&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTD<span style="color:#ff9d00;font-weight:700">);</span></div></div><br /><strong><h1>Работа с цифровым выходом</h1></strong><br /><br /><h2>	Цифровой выход PB1. Требуется выдать на этот выход значение логической единицы. Это можно сделать с помощью функции </h2><strong><h2>PORT_SetBits</h2></strong><h2>:</h2><br /><div class="codebox"><div class="codebox">PORT_SetBits&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTB,&nbsp;PORT_Pin_1<span style="color:#ff9d00;font-weight:700">);</span></div></div><br /><h2>	Первый параметр – название порта, второй – пины, которые нужно установить в единицу. Естественно, можно указать сразу несколько пинов: </h2><em><strong><h2>PORT_SetBits (MDR_PORTB, PORT_Pin_0 | PORT_Pin_1 | PORT_Pin_2);</h2></strong></em><h2> Если среди указанных пинов попадется цифровой вход, то ничего страшного не произойдет: эта линия будет проигнорирована. Выходы в пределах выбранного порта, которые не указаны при вызове функции, не будут подвергаться какому-либо воздействию. Для установки на выходе значения логического нуля можно применить функцию </h2><strong><h2>PORT_ResetBits</h2></strong><h2>, например:</h2><br /><div class="codebox"><div class="codebox">PORT_ResetBits&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTB,&nbsp;PORT_Pin_1<span style="color:#ff9d00;font-weight:700">);</span></div></div><br /><h2>Функция </h2><strong><h2>PORT_WriteBit </h2></strong><h2>позволяет установить выбранные выходы в указанное состояние (Bit_RESET – в 0; Bit_SET – в 1). В следующем примере в ноль будут установлены выходы PB0 и PB1, остальные же линии порта B никак не будут затронуты:</h2><br /><div class="codebox"><div class="codebox">PORT_WriteBit&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTB,&nbsp;PORT_Pin_0&nbsp;<span style="color:#ff9d00;font-weight:700">|</span>&nbsp;PORT_Pin_1,&nbsp;Bit_RESET<span style="color:#ff9d00;font-weight:700">);</span></div></div><br /><h2>Функция </h2><strong><h2>PORT_Write</h2></strong><h2> позволяет просто записать в указанный порт (т.е. во всю совокупность его линий) требуемое значение, заданное 16-битным целым числом. В следующем примере линии PB0 и PB3 будут установлены в единицу, а остальные линии порта B – в ноль:<br /></h2><div class="codebox"><div class="codebox">PORT_Write&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTB,&nbsp;0x0009<span style="color:#ff9d00;font-weight:700">);</span></div></div><br />Таким образом, при вызове функции <strong>PORT_Write</strong> воздействию подвергаются все выходы в пределах выбранного порта. Линии, не являющиеся выходами, естественно, не затрагиваются. Нередко требуется узнать, в каком состоянии сейчас находится тот или иной цифровой выход. Для этого можно применить функцию <strong>PORT_ReadInputDataBit()</strong> и <strong>PORT_ReadInputData()</strong>. Дело в том, что при их вызове в любом случае возвращается состояние линий ввода/вывода независимо от того, вход это или выход. В следующем примере в переменную flag считывается состояние выхода PB0:<br /><div class="codebox"><div class="codebox">uint8_t&nbsp;flag<span style="color:#ff9d00;font-weight:700">;</span><br />...<br />flag&nbsp;=&nbsp;PORT_ReadInputDataBit&nbsp;<span style="color:#ff9d00;font-weight:700">(</span>MDR_PORTB,&nbsp;PORT_Pin_0<span style="color:#ff9d00;font-weight:700">);</span></div></div><br />Если выход установлен в 1, то и переменной flag присвоится значение 1. Если же выход установлен в 0, то и переменной flag присвоится значение 0.<br /><br /><strong><h1>Работа с кнопками</h1></strong><br /><br /><h2>На рисунке кнопка подключена к выводу PD5. Пока кнопка не нажата, вывод PD5 через резистор притянут к +3,3 В, следовательно, на нем будет напряжение логической единицы (те же +3,3 В). Если кнопку нажать, вывод PD5 притянется к цепи питания 0 В, т.е. на PD5 будет напряжение логического нуля.</h2><br /><a href=""><img src="images\2-1.png" alt="images\2-1.png" /></a><br /><br /><div class="codebox"><div class="codebox"><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;MDR32F9Qx_port.h&gt;</span><br /><span style="color:#7f0044;font-weight:700">#include&nbsp;&lt;MDR32F9Qx_rst_clk.h&gt;</span><br /><br /><span style="color:#7f0044;font-weight:700">#define&nbsp;LED1&nbsp;PORT_Pin_1&nbsp;//определить&nbsp;вывод&nbsp;как&nbsp;LED1</span><br /><span style="color:#7f0044;font-weight:400">static</span>&nbsp;PORT_InitTypeDef&nbsp;PortInit;&nbsp;<span style="color:#0088ff;font-weight:400">//объявление&nbsp;структуры&nbsp;PortInit</span><br /><br /><span style="color:#7f0044;font-weight:400">int</span>&nbsp;main()<br />	{<br />		RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTD,&nbsp;ENABLE);<span style="color:#0088ff;font-weight:400">//включить&nbsp;тактирование&nbsp;порта&nbsp;D</span><br />		RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTB,&nbsp;ENABLE);&nbsp;<span style="color:#0088ff;font-weight:400">//включить&nbsp;тактирование&nbsp;порта&nbsp;B</span><br />		<span style="color:#0088ff;font-weight:400">//Инициализация&nbsp;порта&nbsp;D&nbsp;для&nbsp;кнопки</span><br />		PortInit.PORT_OE&nbsp;=&nbsp;PORT_OE_IN;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;направление&nbsp;передачи&nbsp;данных&nbsp;=&nbsp;вход</span><br />		PortInit.PORT_FUNC&nbsp;=&nbsp;PORT_FUNC_PORT;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;режим&nbsp;работы&nbsp;вывода&nbsp;порта&nbsp;=&nbsp;Порт</span><br />		PortInit.PORT_MODE&nbsp;=&nbsp;PORT_MODE_DIGITAL;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;режим&nbsp;работы&nbsp;выводе&nbsp;=&nbsp;цифровой</span><br />		PortInit.PORT_SPEED&nbsp;=&nbsp;PORT_SPEED_SLOW;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;скорость&nbsp;фронта&nbsp;вывода&nbsp;=&nbsp;медленный</span><br />		PortInit.PORT_Pin&nbsp;=&nbsp;(PORT_Pin_5);&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;выбор&nbsp;вывода&nbsp;5&nbsp;для&nbsp;инициализации</span><br />		PORT_Init(MDR_PORTD,&nbsp;&amp;PortInit);&nbsp;<span style="color:#0088ff;font-weight:400">//инициализация&nbsp;порта&nbsp;С&nbsp;заданными&nbsp;параметрами</span><br />		<span style="color:#0088ff;font-weight:400">//Инициализация&nbsp;порта&nbsp;B&nbsp;для&nbsp;светодиода</span><br />		PortInit.PORT_OE&nbsp;=&nbsp;PORT_OE_OUT;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;направление&nbsp;передачи&nbsp;данных&nbsp;=&nbsp;Выход</span><br />		PortInit.PORT_FUNC&nbsp;=&nbsp;PORT_FUNC_PORT;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;режим&nbsp;работы&nbsp;вывода&nbsp;порта&nbsp;=&nbsp;Порт</span><br />		PortInit.PORT_MODE&nbsp;=&nbsp;PORT_MODE_DIGITAL;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;режим&nbsp;работы&nbsp;вывода&nbsp;	=&nbsp;Цифровой</span><br />		PortInit.PORT_SPEED&nbsp;=&nbsp;PORT_SPEED_SLOW;&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;скорость&nbsp;фронта&nbsp;вывода&nbsp;=&nbsp;медленный</span><br />		PortInit.PORT_Pin&nbsp;=&nbsp;(PORT_Pin_All);<span style="color:#0088ff;font-weight:400">//&nbsp;выбор&nbsp;всех&nbsp;выводов&nbsp;для&nbsp;инициализации</span><br />		PORT_Init(MDR_PORTB,&nbsp;&amp;PortInit);&nbsp;<span style="color:#0088ff;font-weight:400">//инициализация&nbsp;порта&nbsp;B&nbsp;заданными&nbsp;параметрами</span><br />		PORT_SetBits(MDR_PORTB,&nbsp;PORT_Pin_All);&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;включить&nbsp;все&nbsp;светодиоды&nbsp;при&nbsp;старте</span><br /><br />	<span style="color:#ff9d00;font-weight:700">while</span>(<span style="color:#ff0044;font-weight:400">1</span>)<br />		{&nbsp;<br />		<span style="color:#ff9d00;font-weight:700">if</span>&nbsp;(PORT_ReadInputDataBit(MDR_PORTD,PORT_Pin_5)&nbsp;==&nbsp;<span style="color:#ff0044;font-weight:400">0</span>)<br /><span style="color:#0088ff;font-weight:400">//если&nbsp;кнопка&nbsp;не&nbsp;нажата…</span><br />		{<br />			PORT_SetBits(MDR_PORTB,&nbsp;LED1);&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;включить&nbsp;светодиод&nbsp;на&nbsp;выводе&nbsp;1&nbsp;порта&nbsp;B</span><br />		}<br />		<span style="color:#ff9d00;font-weight:700">else</span><br />		{<br />			PORT_ResetBits(MDR_PORTB,&nbsp;LED1);&nbsp;<span style="color:#0088ff;font-weight:400">//&nbsp;выключить&nbsp;светодиод&nbsp;на&nbsp;выводе&nbsp;1&nbsp;порта&nbsp;B</span><br />		}<br />		}<br />	}</div></div><br /><br /></div><div class='page'><h1 class='title level-2'>Работа с UART</h1><br/><strong><h2>Передача символа на ПК каждые 5 секунд</h2></strong>.<br /><h2>Вывод 1 порта F назначен в качестве линии передачи TXD приемопередатчика UART, а вывод 0 того же порта – в качестве линии приема RXD. При старте микроконтроллер начинает отсылать по<br />последовательному интерфейсу на вход приемопередатчика UART цифровое значение переменной iкаждые 5 секунды. Значение переменной i после каждой отправки увеличивается на 1.</h2><br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;MDR32F9Qx_uart.h&quot;<br />#include&nbsp;&quot;MDR32F9Qx_port.h&quot;<br />#include&nbsp;&quot;MDR32F9Qx_rst_clk.h&quot;<br /><br />static&nbsp;PORT_InitTypeDef&nbsp;PortInit;//объявление&nbsp;структуры&nbsp;PortInit<br />static&nbsp;UART_InitTypeDef&nbsp;UART_InitStructure;//объявление&nbsp;структуры&nbsp;UART_InitStructure<br />volatile&nbsp;uint32_t&nbsp;delay_dec&nbsp;=&nbsp;0;//&nbsp;объявление&nbsp;переменной&nbsp;delay_dec<br /><br />//Обработчик&nbsp;прерывания&nbsp;системного&nbsp;таймера<br />void&nbsp;SysTick_Handler&nbsp;(void)<br />{<br />&nbsp;&nbsp;if&nbsp;(delay_dec&nbsp;!=0)&nbsp;delay_dec--;<br />}<br />//функция&nbsp;временной&nbsp;задержки<br />void&nbsp;delay_ms&nbsp;(uint32_t&nbsp;delay_ms)<br />{<br />&nbsp;&nbsp;delay_dec&nbsp;=&nbsp;delay_ms;<br />&nbsp;&nbsp;while&nbsp;(delay_dec)&nbsp;{};<br />}<br /><br />int&nbsp;main&nbsp;(void)<br />{<br />&nbsp;&nbsp;uint8_t&nbsp;i&nbsp;=&nbsp;0;//объявление&nbsp;переменной&nbsp;счетчика,&nbsp;хранящей&nbsp;передаваемое&nbsp;по&nbsp;UARTзначение<br />&nbsp;&nbsp;//Инициализация&nbsp;системного&nbsp;таймера&nbsp;для&nbsp;функции&nbsp;задержки&nbsp;(см.&nbsp;4.2)<br />&nbsp;&nbsp;SysTick-&gt;LOAD&nbsp;|=&nbsp;(8000000/1000)-1;<br />&nbsp;&nbsp;SysTick-&gt;CTRL&nbsp;|=&nbsp;SysTick_CTRL_CLKSOURCE_Pos;<br />&nbsp;&nbsp;SysTick-&gt;CTRL&nbsp;|=&nbsp;SysTick_CTRL_COUNTFLAG_Pos;<br />&nbsp;&nbsp;SysTick-&gt;CTRL&nbsp;|=&nbsp;~SysTick_CTRL_ENABLE_Pos;<br />&nbsp;&nbsp;RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTF,ENABLE);&nbsp;//включить&nbsp;тактирование&nbsp;порта&nbsp;F<br /><br />&nbsp;&nbsp;//Инициализация&nbsp;порта&nbsp;F&nbsp;для&nbsp;функции&nbsp;UART<br />&nbsp;&nbsp;PortInit.PORT_PULL_UP&nbsp;=&nbsp;PORT_PULL_UP_OFF;//подтяжка&nbsp;в&nbsp;питание&nbsp;выключена<br />&nbsp;&nbsp;PortInit.PORT_PULL_DOWN&nbsp;=&nbsp;PORT_PULL_DOWN_OFF;//подтяжка&nbsp;в&nbsp;ноль&nbsp;выключена<br />&nbsp;&nbsp;PortInit.PORT_PD_SHM&nbsp;=&nbsp;PORT_PD_SHM_OFF;//режим&nbsp;триггера&nbsp;Шмитта&nbsp;выключен<br />&nbsp;&nbsp;PortInit.PORT_PD&nbsp;=&nbsp;PORT_PD_DRIVER;//режим&nbsp;управляемого&nbsp;драйвера<br />&nbsp;&nbsp;PortInit.PORT_GFEN&nbsp;=&nbsp;PORT_GFEN_OFF;//входной&nbsp;фильтр&nbsp;выключен<br />&nbsp;&nbsp;PortInit.PORT_FUNC&nbsp;=&nbsp;PORT_FUNC_ALTER;//альтернативная&nbsp;функция&nbsp;порта<br />&nbsp;&nbsp;PortInit.PORT_SPEED&nbsp;=&nbsp;PORT_SPEED_MAXFAST;//скорость&nbsp;фронта&nbsp;вывода&nbsp;=&nbsp;быстрая<br />&nbsp;&nbsp;PortInit.PORT_MODE&nbsp;=&nbsp;PORT_MODE_DIGITAL;&nbsp;//режим&nbsp;работы&nbsp;вывода&nbsp;=&nbsp;цифровой<br />&nbsp;&nbsp;//Инициализация&nbsp;вывода&nbsp;1&nbsp;как&nbsp;UART_TX<br />&nbsp;&nbsp;PortInit.PORT_Pin&nbsp;=&nbsp;PORT_Pin_1;<br />&nbsp;&nbsp;PORT_Init(MDR_PORTF,&nbsp;&amp;PortInit);<br />&nbsp;&nbsp;//Инициализация&nbsp;вывода&nbsp;0&nbsp;как&nbsp;UART_RX<br />&nbsp;&nbsp;PortInit.PORT_OE&nbsp;=&nbsp;PORT_OE_IN;<br />&nbsp;&nbsp;PortInit.PORT_Pin&nbsp;=&nbsp;PORT_Pin_0;<br />&nbsp;&nbsp;PORT_Init(MDR_PORTF,&nbsp;&amp;PortInit);<br />&nbsp;&nbsp;RST_CLK_CPU_PLLconfig&nbsp;(RST_CLK_CPU_PLLsrcHSIdiv2,0);//конфигурация&nbsp;источника&nbsp;тактирования&nbsp;HSI&nbsp;делением&nbsp;частоты&nbsp;на&nbsp;2&nbsp;и&nbsp;без&nbsp;умножения<br />&nbsp;&nbsp;RST_CLK_PCLKcmd(RST_CLK_PCLK_UART1,&nbsp;ENABLE);&nbsp;//включить&nbsp;тактирование&nbsp;UART<br />&nbsp;&nbsp;UART_BRGInit(MDR_UART1,&nbsp;UART_HCLKdiv1);//делитель&nbsp;тактовой&nbsp;частоты&nbsp;UART&nbsp;=&nbsp;1<br />&nbsp;&nbsp;//Конфигурация&nbsp;UART<br />&nbsp;&nbsp;UART_InitStructure.UART_BaudRate&nbsp;=&nbsp;115000;&nbsp;//скорость&nbsp;передачи&nbsp;данных&nbsp;15000&nbsp;бод/сек<br />&nbsp;&nbsp;UART_InitStructure.UART_WordLength&nbsp;=&nbsp;UART_WordLength8b;//длина&nbsp;слова&nbsp;в&nbsp;посылке&nbsp;=&nbsp;8бит<br />&nbsp;&nbsp;UART_InitStructure.UART_StopBits&nbsp;=&nbsp;UART_StopBits1;//один&nbsp;стоповый&nbsp;бит<br />&nbsp;&nbsp;UART_InitStructure.UART_Parity&nbsp;=&nbsp;UART_Parity_No;//без&nbsp;проверки&nbsp;четности<br />&nbsp;&nbsp;UART_InitStructure.UART_FIFOMode&nbsp;=&nbsp;UART_FIFO_ON;//включить&nbsp;работу&nbsp;буфера&nbsp;FIFO&nbsp;приемника&nbsp;и&nbsp;передачи<br />&nbsp;&nbsp;UART_InitStructure.UART_HardwareFlowControl&nbsp;=&nbsp;UART_HardwareFlowControl_RXE&nbsp;|&nbsp;UART_HardwareFlowControl_TXE;//Разрешить&nbsp;прием,&nbsp;разрешить&nbsp;передачу&nbsp;данных<br />&nbsp;&nbsp;//Инициализация&nbsp;UART&nbsp;с&nbsp;заданными&nbsp;параметрами<br />&nbsp;&nbsp;UART_Init&nbsp;(MDR_UART1,&amp;UART_InitStructure);<br />&nbsp;&nbsp;UART_Cmd(MDR_UART1,ENABLE);&nbsp;//включить&nbsp;сконфигурированный&nbsp;UART<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;while&nbsp;(1)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;UART_SendData&nbsp;(MDR_UART1,&nbsp;i++);&nbsp;//Послать&nbsp;значение&nbsp;счетчика&nbsp;по&nbsp;UART,&nbsp;и&nbsp;прибавить&nbsp;к&nbsp;нему&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;delay_ms(5000);//подождать&nbsp;5&nbsp;секунд<br />&nbsp;&nbsp;}<br />}</div></div><br /><br /></div></body></html>